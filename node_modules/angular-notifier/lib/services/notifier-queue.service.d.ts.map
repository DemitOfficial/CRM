{"version":3,"file":"notifier-queue.service.d.ts","sources":["notifier-queue.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { Subject } from 'rxjs';\nimport { NotifierAction } from '../models/notifier-action.model';\n/**\n * Notifier queue service\n *\n * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls\n * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -\n * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and\n * processes them at the right time (which is when the previous action has been processed successfully).\n *\n * Technical sidenote:\n * An action looks pretty similar to the ones within the Flux / Redux pattern.\n */\nexport declare class NotifierQueueService {\n    /**\n     * Stream of actions, subscribable from outside\n     */\n    readonly actionStream: Subject<NotifierAction>;\n    /**\n     * Queue of actions\n     */\n    private actionQueue;\n    /**\n     * Flag, true if some action is currently in progress\n     */\n    private isActionInProgress;\n    /**\n     * Constructor\n     */\n    constructor();\n    /**\n     * Push a new action to the queue, and try to run it\n     *\n     * @param action Action object\n     */\n    push(action: NotifierAction): void;\n    /**\n     * Continue with the next action (called when the current action is finished)\n     */\n    continue(): void;\n    /**\n     * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n     */\n    private tryToRunNextAction;\n}\n"]}