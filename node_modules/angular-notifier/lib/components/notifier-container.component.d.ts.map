{"version":3,"file":"notifier-container.component.d.ts","sources":["notifier-container.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ChangeDetectorRef, OnDestroy } from '@angular/core';\nimport { NotifierNotification } from '../models/notifier-notification.model';\nimport { NotifierService } from '../services/notifier.service';\nimport { NotifierQueueService } from '../services/notifier-queue.service';\nimport { NotifierNotificationComponent } from './notifier-notification.component';\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\nexport declare class NotifierContainerComponent implements OnDestroy {\n    /**\n     * List of currently somewhat active notifications\n     */\n    notifications: Array<NotifierNotification>;\n    /**\n     * Change detector\n     */\n    private readonly changeDetector;\n    /**\n     * Notifier queue service\n     */\n    private readonly queueService;\n    /**\n     * Notifier configuration\n     */\n    private readonly config;\n    /**\n     * Queue service observable subscription (saved for cleanup)\n     */\n    private queueServiceSubscription;\n    /**\n     * Promise resolve function reference, temporarily used while the notification child component gets created\n     */\n    private tempPromiseResolver;\n    /**\n     * Constructor\n     *\n     * @param changeDetector       Change detector, used for manually triggering change detection runs\n     * @param notifierQueueService Notifier queue service\n     * @param notifierService      Notifier service\n     */\n    constructor(changeDetector: ChangeDetectorRef, notifierQueueService: NotifierQueueService, notifierService: NotifierService);\n    /**\n     * Component destroyment lifecycle hook, cleans up the observable subsciption\n     */\n    ngOnDestroy(): void;\n    /**\n     * Notification identifier, used as the ngFor trackby function\n     *\n     * @param   index        Index\n     * @param   notification Notifier notification\n     * @returns Notification ID as the unique identnfier\n     */\n    identifyNotification(index: number, notification: NotifierNotification): string;\n    /**\n     * Event handler, handles clicks on notification dismiss buttons\n     *\n     * @param notificationId ID of the notification to dismiss\n     */\n    onNotificationDismiss(notificationId: string): void;\n    /**\n     * Event handler, handles notification ready events\n     *\n     * @param notificationComponent Notification component reference\n     */\n    onNotificationReady(notificationComponent: NotifierNotificationComponent): void;\n    /**\n     * Handle incoming actions by mapping action types to methods, and then running them\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n    private handleAction;\n    /**\n     * Show a new notification\n     *\n     * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n    private handleShowAction;\n    /**\n     * Continue to show a new notification (after the notification components is initialized / created / rendered).\n     *\n     * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n     * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n     * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n     * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n     *\n     * @param notification New notification to show\n     */\n    private continueHandleShowAction;\n    /**\n     * Hide an existing notification\n     *\n     * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n     * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n     * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n     *\n     * @param   action Action object, payload contains the notification ID\n     * @returns Promise, resolved when done\n     */\n    private handleHideAction;\n    /**\n     * Hide the oldest notification (bridge to handleHideAction)\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n    private handleHideOldestAction;\n    /**\n     * Hide the newest notification (bridge to handleHideAction)\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n    private handleHideNewestAction;\n    /**\n     * Hide all notifications at once\n     *\n     * @returns Promise, resolved when done\n     */\n    private handleHideAllAction;\n    /**\n     * Shift multiple notifications at once\n     *\n     * @param   notifications List containing the notifications to be shifted\n     * @param   distance      Distance to shift (in px)\n     * @param   toMakePlace   Flag, defining in which direciton to shift\n     * @returns Promise, resolved when done\n     */\n    private shiftNotifications;\n    /**\n     * Add a new notification to the list of notifications (triggers change detection)\n     *\n     * @param notification Notification to add to the list of notifications\n     */\n    private addNotificationToList;\n    /**\n     * Remove an existing notification from the list of notifications (triggers change detection)\n     *\n     * @param notification Notification to be removed from the list of notifications\n     */\n    private removeNotificationFromList;\n    /**\n     * Remove all notifications from the list (triggers change detection)\n     */\n    private removeAllNotificationsFromList;\n    /**\n     * Helper: Find a notification in the notification list by a given notification ID\n     *\n     * @param   notificationId Notification ID, used for finding notification\n     * @returns Notification, undefined if not found\n     */\n    private findNotificationById;\n    /**\n     * Helper: Find a notification's index by a given notification ID\n     *\n     * @param   notificationId Notification ID, used for finding a notification's index\n     * @returns Notification index, undefined if not found\n     */\n    private findNotificationIndexById;\n}\n"]}