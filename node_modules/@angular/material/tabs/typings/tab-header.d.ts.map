{"version":3,"file":"tab-header.d.ts","sources":["tab-header.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Direction, Directionality } from '@angular/cdk/bidi';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { AfterContentChecked, AfterContentInit, ChangeDetectorRef, ElementRef, EventEmitter, NgZone, OnDestroy, QueryList, AfterViewInit } from '@angular/core';\nimport { CanDisableRipple, CanDisableRippleCtor } from '@angular/material/core';\nimport { MatInkBar } from './ink-bar';\nimport { MatTabLabelWrapper } from './tab-label-wrapper';\nimport { Platform } from '@angular/cdk/platform';\n/**\n * The directions that scrolling can go in when the header's tabs exceed the header width. 'After'\n * will scroll the header towards the end of the tabs list and 'before' will scroll towards the\n * beginning of the list.\n */\nexport declare type ScrollDirection = 'after' | 'before';\n/** @docs-private */\ndeclare class MatTabHeaderBase {\n}\ndeclare const _MatTabHeaderMixinBase: CanDisableRippleCtor & typeof MatTabHeaderBase;\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n * @docs-private\n */\nexport declare class MatTabHeader extends _MatTabHeaderMixinBase implements AfterContentChecked, AfterContentInit, AfterViewInit, OnDestroy, CanDisableRipple {\n    private _elementRef;\n    private _changeDetectorRef;\n    private _viewportRuler;\n    private _dir;\n    private _ngZone;\n    private _platform;\n    _labelWrappers: QueryList<MatTabLabelWrapper>;\n    _inkBar: MatInkBar;\n    _tabListContainer: ElementRef;\n    _tabList: ElementRef;\n    _nextPaginator: ElementRef<HTMLElement>;\n    _previousPaginator: ElementRef<HTMLElement>;\n    /** The distance in pixels that the tab labels should be translated to the left. */\n    private _scrollDistance;\n    /** Whether the header should scroll to the selected index after the view has been checked. */\n    private _selectedIndexChanged;\n    /** Emits when the component is destroyed. */\n    private readonly _destroyed;\n    /** Whether the controls for pagination should be displayed */\n    _showPaginationControls: boolean;\n    /** Whether the tab list can be scrolled more towards the end of the tab label list. */\n    _disableScrollAfter: boolean;\n    /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\n    _disableScrollBefore: boolean;\n    /**\n     * The number of tab labels that are displayed on the header. When this changes, the header\n     * should re-evaluate the scroll position.\n     */\n    private _tabLabelCount;\n    /** Whether the scroll distance has changed and should be applied after the view is checked. */\n    private _scrollDistanceChanged;\n    /** Used to manage focus between the tabs. */\n    private _keyManager;\n    /** Cached text content of the header. */\n    private _currentTextContent;\n    /** Stream that will stop the automated scrolling. */\n    private _stopScrolling;\n    /** The index of the active tab. */\n    selectedIndex: number;\n    private _selectedIndex;\n    /** Event emitted when the option is selected. */\n    readonly selectFocusedIndex: EventEmitter<number>;\n    /** Event emitted when a label is focused. */\n    readonly indexFocused: EventEmitter<number>;\n    constructor(_elementRef: ElementRef, _changeDetectorRef: ChangeDetectorRef, _viewportRuler: ViewportRuler, _dir: Directionality, _ngZone: NgZone, _platform: Platform);\n    ngAfterContentChecked(): void;\n    /** Handles keyboard events on the header. */\n    _handleKeydown(event: KeyboardEvent): void;\n    /**\n     * Aligns the ink bar to the selected tab on load.\n     */\n    ngAfterContentInit(): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     */\n    _onContentChanges(): void;\n    /**\n     * Updates the view whether pagination should be enabled or not.\n     *\n     * WARNING: Calling this method can be very costly in terms of performance.  It should be called\n     * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n     * page.\n     */\n    updatePagination(): void;\n    /** Tracks which element has focus; used for keyboard navigation */\n    /** When the focus index is set, we must manually send focus to the correct label */\n    focusIndex: number;\n    /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     */\n    _isValidIndex(index: number): boolean;\n    /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     */\n    _setTabFocus(tabIndex: number): void;\n    /** The layout direction of the containing app. */\n    _getLayoutDirection(): Direction;\n    /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n    _updateTabScrollPosition(): void;\n    /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n    scrollDistance: number;\n    /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    _scrollHeader(direction: ScrollDirection): {\n        maxScrollDistance: number;\n        distance: number;\n    };\n    /** Handles click events on the pagination arrows. */\n    _handlePaginatorClick(direction: ScrollDirection): void;\n    /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    _scrollToLabel(labelIndex: number): void;\n    /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    _checkPaginationEnabled(): void;\n    /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    _checkScrollingControls(): void;\n    /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    _getMaxScrollDistance(): number;\n    /** Tells the ink-bar to align itself to the current label wrapper */\n    _alignInkBarToSelectedTab(): void;\n    /** Stops the currently-running paginator interval.  */\n    _stopInterval(): void;\n    /**\n     * Handles the user pressing down on one of the paginators.\n     * Starts scrolling the header after a certain amount of time.\n     * @param direction In which direction the paginator should be scrolled.\n     */\n    _handlePaginatorPress(direction: ScrollDirection): void;\n    /**\n     * Scrolls the header to a given position.\n     * @param position Position to which to scroll.\n     * @returns Information on the current scroll distance and the maximum.\n     */\n    private _scrollTo;\n}\nexport {};\n"]}